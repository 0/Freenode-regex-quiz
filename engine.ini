[script]
n0=/*
n1=
n2=Syntax: $validateRegex(<ID>, <task N>, <regex and substitution>)
n3=
n4=Eg:     $validateRegex(username, 15, /expression/ subtext)
n5=
n6=The ID should be valid and already established in users.ini. It will
n7=be used to keep track of the number of attempts and perhaps other 
n8=tidbits of information and statistics. 
n9=
n10=This performs two layers of testing. The first validates the regex
n11=and separates it from potential substitution text (if relevant to the 
n12=given task). The second goes through the test file and checks the
n13=correctness of the attempt.
n14=
n15=It will trigger a signal event named 'validated' with the following
n16=parameters:
n17=
n18=<ID> <task N> <response code> <optional message>
n19=
n20=The response code is an integer encoded message which the calling routine
n21=can use to generate error messages. The codes are as follows:
n22=
n23=0 - Attempt was successful on all tests and is valid.
n24=1 - Attempt failed a certain test, details in the message.
n25=2 - User has not reached the given task yet.
n26=3 - User has already queued a task to validate.
n27=4 - The given regex is formatted incorrectly.
n28=5 - Substitution text was provided on a task that doesn't require it.
n29=
n30=*/
n31=
n32=alias validateRegex {
n33=
n34=  var %output = .signal validate $1-2, %isSub = 0
n35=
n36=  ; First layer of validation
n37=
n38=  if ($regexUser($1, info, reached) !>= $2) {
n39=    %output 2
n40=    return
n41=  }
n42=
n43=  if ($hget(regexDist, $1)) {
n44=    %output 3
n45=    return
n46=  }
n47=
n48=  ; Include an expression which fills $regml(validate, 1) with the input regex
n49=  ; and $regml(validate, 2) with substitution text.
n50=  if (!$reVal($3).pat) {
n51=    %output 4
n52=    return
n53=  }
n54=
n55=  if ($regexTask($2, sub)) {
n56=    %isSub = 1
n57=  }
n58=  elseif ($reVal($3).sub) {
n59=    %output 5
n60=    return
n61=  }
n62=
n63=  checkTask $2
n64=
n65=  hadd -m regexDist $1 $+(%isSub, $lf, $2, $lf, $reVal($3).pat, $lf, $reVal($3).sub)
n66=  .timer 1 0 regexDist $1
n67=}
n68=
n69=; $regexUser(<ID>, <section>, <item>)
n70=; or 
n71=; /regexUser <ID> <section> <item> <value>
n72=
n73=alias regexUser {
n74=  if ($isid) return $readini($regexDir $+ users\ $+ $1.ini, n, $2, $3)
n75=  writeini -n $qt($regexDir $+ users\ $+ $1.ini) $2-
n76=}
n77=
n78=; $regexTask(<N>, <item>)
n79=; or
n80=; /regexTask <N> <item> <value>
n81=
n82=alias regexTask {
n83=  if ($isid) return $readini($regexdir $+ tasks.ini, n, task $+ $1, $2) 
n84=  writeini -n $qt($regexdir $+ tasks.ini) task $+ $1-
n85=}
n86=
n87=; $regexTasks()
n88=
n89=alias regexTasks return $ini($qt($+($regexDir,tasks.ini)),0)
n90=
n91=; /checkTask <task N>
n92=; Checks the test file to see if it's been modified since the last check.
n93=; Updates the number of tests in tasks.ini accordingly and throws any errors
n94=; if it detects them (for example, no substitution text).
n95=
n96=alias checkTask {
n97=  var %file = $qt($regexdir $+ tests\task $+ $1.txt), %mtime = $file(%file).mtime
n98=  if ($regexTask($1, testMtime) != %mtime) {
n99=    if ($fopen(checkTask)) .fclose checkTask
n100=    .fopen checkTask %file
n101=    if (!$ferr) {
n102=      var %task = $1, %line, %testNum = 0, %inTest, %testLine, %sub = $regexTask($1, sub)
n103=      while (!$ferr) && (!$feof) {
n104=        %line = $fread(checkTask)
n105=        if (;* !iswm %line) {
n106=          if (%line != $null) {
n107=            if (!%inTest) {
n108=              %inTest = 1
n109=              %testLine =
n110=              inc %testNum
n111=              tokenize 32 %line
n112=              if (!%sub) && (0 $1 $2) /
n113=              :back
n114=            }
n115=            inc %testLine
n116=          }
n117=          else { 
n118=            if (%inTest) && (%testLine != 3) echo -egac info Test %testNum has an incorrect number of lines.
n119=            %inTest =
n120=          }
n121=        }
n122=      }
n123=      if (%inTest) && (%testLine != 3) echo -egac info Test %testNum has an incorrect number of lines.
n124=      regexTask %task tests %testNum
n125=      regexTask %task testMtime %mtime
n126=    }
n127=    .fclose checkTask
n128=  }
n129=  return
n130=  :error
n131=  if (* /if: * unknown * iswm $error) {
n132=    reseterror
n133=    echo -egac info Test %testNum contains an invalid comparison.
n134=    goto back
n135=  }
n136=}
n137=
n138=; /regexDist <ID>
n139=; Distribute processing time between all those who have requested to have 
n140=; a regex validated, starting with <ID>.
n141=
n142=alias regexDist {
n143=  tokenize 10 $+($1, $lf, $hget(regexDist, $1))
n144=  if ($regexUser($1, task $+ $3, attempts) !isnum 1-) {
n145=    regexTask $3 total $calc(1 + $regexTask($3, total))
n146=  } 
n147=  regexUser $1 task $+ $3 attempts $calc(1 + $v1)
n148=  regexUser $1 task $+ $3 last $4-5
n149=  var %file = $qt($regexDir $+ tests\task $+ $3.txt)
n150=  if ($fopen(regexDist)) .fclose regexDist
n151=  .fopen regexDist %file
n152=  if (!$ferr) {
n153=    var %line, %testNum = 0, %out .signal validate $1 $3, %op ==, %v2, %input, %output, %result, %regex 1, %error
n154=    while (!$ferr) && (!$feof) {
n155=      %line = $fread(regexDist)
n156=      if (;* !iswm %line) {
n157=        if (%line != $null) {
n158=          inc %testNum
n159=          if ($2) {
n160=            %input = %line
n161=            %output = $fread(regexDist)
n162=            noop $regsub(regexDist, %input, $4, $5, %result)
n163=          }
n164=          else {
n165=            %op = $gettok(%line, 1, 32)
n166=            %v2 = $gettok(%line, 2, 32)
n167=            %input = $fread(regexDist)
n168=            %regex = $regex(regexDist, %input, $4)
n169=          }
n170=          %error = $fread(regexDist)
n171=          if (%regex %op %v2) || (%result !=== %output) {
n172=            ;%out 1 Failed on test %testNum $+ . %error
n173=            %out 1 Task $3 $+ . 5Test %testNum of $regexTask($3,tests) failed. %error
n174=            regexUser $1 task $+ $3 fail (test %testNum of $regexTask($3,tests) $+ ) %error
n175=            %out 1 Debug: if ( $+ %regex %op %v2 $+ ) || ( $+ %result !=== %output $+ )
n176=            if (!$2) %out 1 Debug: $+($,!regex,$chr(40),regexDist,$chr(44),$chr(32),%input,$chr(44),$chr(32),$4,$chr(41))
n177=            else %out 1 Debug: $+($,!regsubex,$chr(40),regexDist,$chr(44),$chr(32),%input,$chr(44),$chr(32),$4,$chr(44),$chr(32),$5,$chr(41)) -> %result
n178=            .fclose regexDist
n179=            return
n180=          }
n181=        }
n182=      }
n183=    }
n184=    if ($len($regexUser($1, task $+ $3, shortest)) == 0) || ($v1 > $len($4-5)) {
n185=      if (!$v1) regexTask $3 success $calc(1 + $regexTask($3, success))
n186=      regexUser $1 task $+ $3 shortest $4-5
n187=    }
n188=    if ($gettok($regexTask($3, shortest), 2, 32) !<= $len($4-5)) regexTask $3 shortest $1 $v2
n189=    %out 0
n190=  }
n191=  .fclose regexDist
n192=}
n193=
n194=
n195=; $reVal(/regex/)
n196=; Validate the regex
n197=alias reVal {
n198=  var %input = $1-, %sre = /^s([^\w\s\\])((?:\\.|(?!\\|\1).)*)\1((?:\\.|(?!\\|\1).)*)\1([gisSmoxXAU]*)\s*$/, $&
n199=    %mre1 = /^(?:m|(?=\/))([^\w\s\\])((?:\\.|(?!\\|\1).)*)\1([gisSmoxXAU]*)\s*$/
n200=  if ($regex(sre,%input,%sre) isnum 1-) {
n201=    var %delim = $regml(sre,1), %pat = $regml(sre,2), %repl = $regml(sre,3), %flags = $regml(sre,4)
n202=    if (%delim != /) {
n203=      ; unescape %delim, and re-escape /
n204=      if (%delim isin |^()[{.+*?\$) var %escape = \ $+ %delim
n205=      else var %escape = %delim
n206=      var %pat = $regsubex(%pat,/(?<!\\)((?:\\\\)*)\\( $+ %escape $+ )/g,\1\2), %pat = $regsubex(%pat,/(?<!\\)((?:\\\\)*)\//g,\1\/)
n207=    }
n208=    var %repl = $regsubex(%repl,/(?<!\\)((?:\\\\)*)\\( $+ %delim $+ )/g,\1\2), %result
n209=    ;return $regsub(repat,%text,$+(/,%pat,/,%flags),%repl,%result)
n210=    return $iif($prop == sub,%repl,$iif($prop == pat,$+(/,%pat,/,%flags)))
n211=  }
n212=  elseif (($regex(mre,%input,%mre1) isnum 1-)) {
n213=    var %delim = $regml(mre,1), %pat = $regml(mre,2), %flags = $regml(mre,3)
n214=    if (%delim != /) {
n215=      if (%delim isin |^()[{.+*?\$) var %escape = \ $+ %delim
n216=      else var %escape = %delim
n217=      var %pat = $regsubex(%pat,/(?<!\\)((?:\\\\)*)\\( $+ %escape $+ )/g,\1\2), %pat = $regsubex(%pat,/(?<!\\)((?:\\\\)*)\//g,\1\/)
n218=    }
n219=    return $iif($prop == pat,$+(/,%pat,/,%flags))
n220=    ;return $regex(repat,%text,$+(/,%pat,/,%flags))
n221=  }
n222=}
n223=
n224=/*
n225=The signal event
n226=0 - Attempt was successful on all tests and is valid.
n227=1 - Attempt failed a certain test, details in the message.
n228=2 - User has not reached the given task yet.
n229=3 - User has already queued a task to validate.
n230=4 - The given regex is formatted incorrectly.
n231=5 - Substitution text was provided on a task that doesn't require it.
n232=6 - Finished the quiz
n233=*/
n234=on *:signal:validate: {
n235=  var %u2n = $username2nick($1)
n236=  if (!$3) {
n237=    var %a = $regexUser($1,info,reached)
n238=    if (%a < $calc($2 +1)) regexUser $1 info reached $v2
n239=    sendTimer %u2n 2 $+ $($regexTask($2,finalMessage),2)
n240=    if ($regexUser($1,info,reached) <= $regexTasks && $regexUser($1,info,reached) == $calc($2 +1)) {
n241=      sendTimer %u2n 3Task $calc($2 +1) of $regexTasks $+ : $+([,$regexTask($calc($2 +1),title),]) $regexTask($calc($2 +1),description)
n242=    }
n243=  }
n244=  else if ($3 == 1) { 
n245=    sendTimer %u2n $4-
n246=  }
n247=  else if ($3 == 2) { 
n248=    ; should never happen
n249=    sendTimer %u2n You have not reached task $2 yet $1 $+ !
n250=  }
n251=  else if ($3 == 3) { 
n252=    sendTimer %u2n You already have a task queued for validation! Please be patient, I'm working as fast as I can!
n253=  }
n254=  else if ($3 == 4) { 
n255=    sendTimer %u2n Your regex is incorrectly formated. It's either /regex/, m/regex/ or s/regex/sub/
n256=  }
n257=  else if ($3 == 5) { 
n258=    sendTimer %u2n You provided a substitution string on a task that does not require it, please try again without it!
n259=  }
n260=  else if ($3 == 6) {
n261=    sendTimer %u2n You have finished the quiz $1 $+ ! You can now look back at your patterns with !mypattern <task> and try to refine and improve them!
n262=  }
n263=  if ($hget(regexDist, $1)) hdel regexDist $1
n264=}
