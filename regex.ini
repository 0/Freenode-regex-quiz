[script]
n0=on $*:text:/(*UTF8)^[@.!] *(explain|regex) +/Si:#: {
n1=  if ($regml(1) == explain) {
n2=    if ($2- != $null) {
n3=      explain $chan $remove($2-,$chr(1),$chr(4))
n4=    } 
n5=    else {
n6=      msg $chan Syntax: !explain /regex/
n7=    }
n8=  }
n9=  elseif ($regml(1) == regex) {
n10=    if ($2- != $null) {
n11=      msg $chan $re($2-)
n12=    } 
n13=    else {
n14=      msg $chan Syntax is: !regex <text> /regex/, !regex <text> s/regex/replacement/
n15=    }
n16=  }
n17=}
n18=on $*:text:/(*UTF8)^[@.?!] *(\S+)/S:#: {
n19=  if ($regml(1) == babewatch) {
n20=    msg $chan babewatch: With 2(?=babe) you only see them when they are in front of you, with 2(?=.*babe) you'll even see them when they are far away and with 2(?<=babe) you'll see them when they are directly behind you.
n21=  }
n22=  if ($regex(loltard,$regml(1),/(*UTF8)(?:look(?:(?:ahead|behind|around)s?))/i)) {
n23=    msg $chan Regular Expressions Zero-Width Assertions (LookArounds: LookAheads & LookBehinds): 2Positive Lookahead (?=re) 2Negative Lookahead (?!re) 2Positive Lookbehind (?<=re) 2Negative Lookbehind (?<!re) 14Lookbehind must be fixed length (you cannot use quantifiers like ? * + or {m,n} for repetition).
n24=  }
n25=  if ($regml(1) == help) {
n26=    msg $chan commands: ? babewatch, ? look(?:ahead|behind|around)s?, !explain /regex/, !regex <text> /regex/, !regex <text> s/regex/replacement/, ? bug
n27=  }
n28=  if ($regml(1) == bug) {
n29=    msg $chan If you have a found a bug with one of the components, please save the data to a file so it can be reproduced and tell Lindrian about it as soon as he is around. Thank you. 
n30=  }
n31=}
n32=on $*:text:/(*UTF8)^[@.!] *(explain|regex) +/Si:?: {
n33=  if ($regml(1) == explain) {
n34=    if ($2) {
n35=      explain $nick $2-
n36=    } 
n37=    else {
n38=      msg $nick Syntax: !explain /regex/
n39=    }
n40=  }
n41=  elseif ($regml(1) == regex) {
n42=    if ($2) {
n43=      msg $nick $re($2-)
n44=    } 
n45=    else {
n46=      msg $nick Syntax is: !regex <text> /regex/, !regex <text> s/regex/replacement/
n47=    }
n48=  }
n49=}
n50=on $*:text:/(*UTF8)^[@.?!] *(\S+)/S:?: {
n51=  if ($regml(1) == babewatch) {
n52=    msg $nick babewatch: With 2(?=babe) you only see them when they are in front of you, with 2(?=.*babe) you'll even see them when they are far away and with 2(?<=babe) you'll see them when they are directly behind you.
n53=  }
n54=  if ($regex(loltard,$regml(1),/(*UTF8)(?:look(?:(?:ahead|behind|around)s?))/i)) {
n55=    msg $nick Regular Expressions Zero-Width Assertions (LookArounds: LookAheads & LookBehinds): 2Positive Lookahead (?=re) 2Negative Lookahead (?!re) 2Positive Lookbehind (?<=re) 2Negative Lookbehind (?<!re) 14Lookbehind must be fixed length (you cannot use quantifiers like ? * + or {m,n} for repetition).
n56=  }
n57=  if ($regml(1) == help) {
n58=    msg $nick commands: ? babewatch, ? look(?:ahead|behind|around)s?, !explain /regex/, !regex <text> /regex/, !regex <text> s/regex/replacement/, ? bug
n59=  }
n60=  if ($regml(1) == bug) {
n61=    msg $nick If you have a found a bug with one of the components, please save the data to a file so it can be reproduced and tell Lindrian about it as soon as he is around. Thank you. 
n62=  }
n63=}
n64=alias explain {
n65=  regex.maketree $iif($1 ischan || $query($1),$1 $attemptFix($2-),$attemptFix($1-))
n66=}
n67=alias -l attemptFix {
n68=  var %pattern = $1-
n69=  ;%pattern = $regsubex(a,%pattern,/(*UTF8){(\d++(?:,?\d*+)?)}/g,$+($chr(65501),$regml(a,1),$chr(65500)))
n70=  %pattern = $regsubex(a,%pattern,/(*UTF8){(?=(\d++(?:,?\d*+)?)\})/g,$chr(65501))
n71=  %pattern = $regsubex(e,%pattern,/(*UTF8) $+ $chr(65501) $+ (\d++(?:,?\d*+)?)\K\}/g,$chr(65500))
n72=  %pattern = $regsubex(b,%pattern,/(*UTF8)(?:(\\k)\{([^\}]++)\}|(\\g)(?:\{(\-?[1-9]|[^\}]+)\}))/g,$+($regml(b,1),$chr(50000),$regml(b,2),$chr(50001)))
n73=  %pattern = $regsubex(c,%pattern,/(*UTF8)(?<!\{\d,|\{\d|{\d,\d)\}/g,$chr(1000))
n74=  %pattern = $regsubex(d,%pattern,/(*UTF8)\{(?!\d+(?:,\d*)?\})/g,$chr(4000))
n75=  %pattern = $replace(%pattern,$chr(65501),$chr(123),$chr(65500),$chr(125))
n76=  %pattern = $replace(%pattern,$chr(50000),$chr(123),$chr(50001),$chr(125))
n77=  returnex $replace(%pattern,$chr(32),$chr(1234))
n78=}
n79=; regex.maketree $iif($1 ischan || $query($1),$1 $replace($2-,$chr(32),\x20),$replace($1-,$chr(32),\x20))
n80=alias -l regex.msg .timerregex. $+ $+($r(a,z),$r(a,z),$r(0,9),$r(0,9)) 1 $calc($iif($regex.timer(regex.*),$v1,-2) +2) regex.msg2 $safe($1-)
n81=
n82=alias safe {
n83=  var %chr1, %chr2, %chr3, %chrs
n84=
n85=  if ($chr(32) isin $1) {
n86=    while ($chr($rand(256, 65535)) isin $1) /
n87=    %chr1 = $v1
n88=  }
n89=
n90=  if ($chr(40) isin $1) {
n91=    while ($chr($rand(256, 65535)) isin $1) /
n92=    %chr2 = $v1
n93=  }
n94=
n95=  if ($chr(41) isin $1) {
n96=    while ($chr($rand(256, 65535)) isin $1) /
n97=    %chr3 = $v1
n98=  }
n99=
n100=  %chrs = , %chr1 , %chr2 , %chr3
n101=
n102=  returnex $!desafe(( $+ $replace($1, $chr(32), %chr1, $chr(40), %chr2, $chr(41), %chr3) ) %chrs ) 
n103=
n104=}
n105=
n106=alias desafe {
n107=  returnex $replace($mid($1, 2, -1), $2, $chr(32), $3, $chr(40), $4, $chr(41))
n108=}
n109=
n110=alias -l regex.msg2 {
n111=  msg $1-
n112=  return
n113=  :error
n114=  reseterror
n115=}
n116=alias -l regex.timer {
n117=  var %a = 1,%x,%r
n118=  while ($timer(%a)) {
n119=    var %r = $regsubex($v1,/(*UTF8)((?<!^\Q $+ $left($1,-1) $+ \E).)+/i,$null)
n120=    if (%r) inc %x
n121=    inc %a
n122=  }
n123=  returnex $iif(%x,%x,0)
n124=}
n125=alias -l regex.echo if ($2) !echo $1-
n126=alias -l regex.MakeTree {
n127=  var %target = $iif($1 != $2 && $2,$1,regex), %pattern = $iif(!$2,$1-,$2-)
n128=  ;var %r = $regex(%pattern,/(*UTF8)^\s*+(?:(m)(.)|()(\/)|()())/)
n129=  ;var %r = $regex(%pattern,/(*UTF8)^\s*+(?:(m)(.)|()([!%@\/='"<>:;_])|()())/)
n130=  var %r = $regex(%pattern,/(*UTF8)^\s*+(?:(m)(.)|()([~!%@\/='"<>:;_])|()())/)
n131=  var %sep = $replace($regml(2),\,\\,',\',$chr(35),\ $+ $chr(35))
n132=
n133=  if (%sep isin |^()[{.+*?$) {
n134=    msg %target Please don't use meta characters as delimiters, it's no good.
n135=    return
n136=  }
n137=
n138=  var %m = $regml(1), %notsep = $iif(%sep != $null,$+($chr(40),?!,%sep,$chr(41)))
n139=  if (%sep != $null && $regex(%pattern,m'\s*+ %m %sep .* %sep [gisSmoXAU]*+ x [gisSmoxXAU]*+$'x)) {
n140=    %r = $regsub(%pattern,/(*UTF8)^\s++/,,%pattern)
n141=    %r = m'(*UTF8)((?:^ %m %sep |(?<!^)\G) (?: \(\?\#[^\)]*+\) |\\Q(?:(?!\\E).)*+\\E |\\(?:[^cQ]|c.) |(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |[^\s\[\]\\] )*+) \s++ 'xg
n142=    %r = $regsub(%pattern,%r,\1,%pattern)
n143=    %r = m'(*UTF8)((?:^ %m %sep |(?<!^)\G) (?: \(\?\#[^\)]*+\) |\\Q(?:(?!\\E).)*+\\E |\\(?:[^cQ]|c.) |(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |[^\#\[\]\\] )*+) \# .*( $iif(%sep != $null,%sep [gisSmoxXAU]*+$) )'xg
n144=    %r = $regsub(%pattern,%r,\1\2,%pattern)
n145=  }
n146=  set -nl %r m'(*UTF8)^\s*+ %m %sep ( ( (?:\Q(*\E(?:NO_START_OPT|CR|LF|CRLF|ANYCRLF|ANY|BSR_ANYCRLF|BSR_UNICODE|UTF8|UCP)\))? (?: \| |( \(\?\#[^\)]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^] |(?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEkg]|k(?:<[^>]++>|\'[^\']++\'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]+)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|\||<?[=!]|(?:P=[^\)]++|P?<[^>]++>|\'[^\']++\'))(?2)|[-ismxXU]*+|R|&[^&\)]++|[-+]?\d++|\((?:<[^>]++>|\'[^\']++\'|(?:R&)?\w+|[+-]\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?:,\d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*)? ) %sep ([gisSmoxXAU]*+)$'x
n147=  if (!$regex(%pattern,%r)) { $iif($me ison %target,regex.msg2 $v2,regex.echo -a) $regex.ShowErrorIn(%target,%pattern,%sep,%m,%notsep) }
n148=  elseif (%target != $null && $left(%target,1) != @) {
n149=    var %pattern = $regml(1), %options = $regml(4)
n150=    set -u0 %regex.BRs 0
n151=    if ($hget(%target)) hdel -w %target Tree.*
n152=    %r = $regex.Explain(%target,%pattern,1,$iif(i isincs %options,$true,$false),$iif(s isincs %options,$true,$false),$iif(m isincs %options,$true,$false),$iif(x isincs %options,$true,$false),$iif(X isincs %options,$true,$false),$iif(U isincs %options,$true,$false))
n153=    %r = $regex.ExplainModifiers(%target,%options,1)
n154=    regex.Hash2Tree %target
n155=  }
n156=}
n157=alias -l regex.ShowErrorIn {
n158=  var %target = $1, %pattern = $2, %sep = $3, %m = $4, %notsep = $5, %ingroup = $6, %gstart, %gend, %r
n159=  var %longdesc = $iif($window(%target) != $null,$true,$false), %cmd = $iif(%longdesc || %target ischan,msg %target,returnex)
n160=  if (!%ingroup) { %r = $regex(%pattern,m'(*UTF8)^(\s*+ %m %sep ( (?: \| |( \(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^] |(?: (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEgk]|k(?:<[^>]++>|'[^']++'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]++)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|<?[=!]|P<[^>]++>)(?2)|[-ismxXU]*+|R|&[^&\)]++|[-+]?\d++|\((?:<[^>]++>|'[^']++'|(?:R&)?\w+|[+-]\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*+)? )'x) }
n161=  if (!%ingroup && $len($regml(1)) == $len(%pattern) && %sep != $null) { %cmd 5Expected `6 $+ %sep $+ 5` to end pattern $+(%pattern,4-Â» here) }
n162=  else {
n163=    if (!%ingroup) %r = $regex(patttrig,%pattern,m'(*UTF8)^(\s*+ %m %sep ( (?: \|| ( \(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^]| (?: (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEgk]|k(?:<[^>]++>|'[^']++'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]++)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|<?[=!]|P<[^>]++>)(?2)|[-ismxXU]*+|R|&[^&\)]++|[-+]?\d++|\((?:<[^>]++>|'[^']++'|(?:R&)?\w+|[+-]\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*)? %sep [gisSmoxXAU]*+ )'x)
n164=    if ( !%ingroup && %r > 0 && %sep != $null && $len($regml(patttrig,1)) != $len(%pattern) && $regex(%pattern,m'(*UTF8)^(\s*+ %m %sep ( (?:(?: (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |(?:\(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[|$^] )(?![?*+{]) |\\c. |\\[^QcbBAZzGE] |\((?:\?(?!\#))?+(?2)\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?+)?+ )*+ (?:\\Q(?:(?!\\E).)*)? ) %sep [a-zA-Z]*+ $ )'x) ) { %cmd 5Invalid modifier in $+($regml(patttrig,1),4here -Â»,$mid(%pattern,$calc($len($regml(patttrig,1)) + 1))) }
n165=    else {
n166=      if ( %ingroup ) {
n167=        %gstart = (
n168=        %gend = )
n169=      }
n170=      else {
n171=        %r = $regsub(%pattern,/^(*UTF8)(\s*+ %m %sep )(.*)( %sep .*)$/x,\2,%pattern)
n172=        %gstart = $regml(1)
n173=        %gend = $regml(3)
n174=      }
n175=      if ( $regex(%pattern,m'(*UTF8)^( ( (?: \|| ( \(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^]| (?: (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEkg]|k(?:<[^>]++>|\'[^\']++\'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]++)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|\||<?[=!]|(?:P=[^\x29]++|P?<[^>]++>|\'[^\']++\'))(?2)|[-ismxXU]*+|R|&[^&\x29]++|[-+]?\d++|\((?:<[^>]++>|\'[^\']++\'|(?:R&)?\w+|[+-]\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*+)?+ ) (.)'x) ) {
n176=        ;                     m'(*UTF8)^\s*+ %m %sep ( ( (?: \| |( \(\?\#[^\)]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^] |(?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEkg]|k(?:<[^>]++>|\'[^\']++\'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]+)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|\||<?[=!]|(?:P=[^\)]++|P?<[^>]++>|\'[^\']++\'))(?2)|[-ismxXU]*+|R|&[^&\)]++|[-+]?\d++|\((?:<[^>]++>|\'[^\']++\'|(?:R&)?\w+|[+-]\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?:,\d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*)? ) %sep ([gisSmoxXAU]*+)$'x
n177=
n178=
n179=        ; if ( $regex(%pattern,m'(*UTF8)^( ( (?: \|| ( \(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^]| (?: (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGEkg]|k(?:<[^>]++>|\'[^\']++\'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]++)\}|[1-9])) |\((?:\?(?:(?:>|[-ismxXU]*+:|<?[=!]|P<[^>]++>)(?2)|[-ismxXU]*+|R|\d++|\((?:\d++|\?<?[=!](?2))\)(?2))|(?!\?)(?2))\)| %notsep [^^$|*+?{}()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?)?+ ) )*+ ) (?:\\Q(?:(?!\\E).)*+)?+ ) (.)'x) ) {
n180=        var %lastbr = $regml(0), %b4 = $regml(1), %after = $mid(%pattern,$regml(%lastbr).pos)
n181=        if ( $regml(%lastbr) == $null ) { %cmd 4Unknown syntax error (I can't find the position) }
n182=        elseif ( $v1 != $chr(40) ) {
n183=          var %char = Invalid character
n184=          if ( $v1 isin +*?{} ) { %char = Quantifier with no preceding token }
n185=          ;elseif ( $v1 isin {} ) { 
n186=          ;  ;explain $gettok(%cmd,2,32) $replace(%pattern,$chr(123),\ $+ $chr(123),$chr(125),\ $+ $chr(125))
n187=          ;  explain $gettok(%cmd,2,32) $replace(%pattern,$chr(123),$chr(65501),$chr(125),$chr(4))
n188=          ;  return
n189=          ;  }
n190=          elseif ( $v1 == [[ ) {
n191=            if ( $mid(%pattern,$calc($regml(4).pos + 1),1) == ]] ) { %char = Empty charater class }
n192=            else { %char = Unbalanced character class }
n193=          }
n194=          elseif ( $v1 == ]] ) { %char = Unbalanced character class }
n195=          elseif ( $v1 == $chr(41) ) {
n196=            %char = Unbalanced bracket
n197=            %r = /(*UTF8)([^\(]*+) \( ( \?\#[^ $+ $chr(41) $+ ]*+ |(?!\?\#)(?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\])|\\Q(?:(?!\\E).)*+\\E|\\(?:c.|[^Qc])|[^()\\]|\((?2)\) )*+ ) \) /xg
n198=            %r = $regsub(%b4,%r,\1(\2),%b4)
n199=            %after = 6) $+ $mid(%after,2)
n200=          }
n201=          %cmd 5 $+ %char in $+ $iif(%ingroup,$chr(32) $+ the group) $+ : $+(%gstart,%b4,4here -Â»,%after,%gend)
n202=        }
n203=        else {
n204=          %r = /(*UTF8)^\((?:(?!\?)|\?(?:\#|>|[-ismxXU]*+:|<?[=!]|P<[^>]++>|[-ismxXU]*+|R|&[^&\)]++|[-+]?\d++|\((?:<[^>]++>|'[^']++'|(?:R&)?\w+|[+-]\d++|\?<?[=!])))/
n205=          if ( !$regex(%after,%r) ) { %cmd 5Invalid construct in $+ $iif(%ingroup,$chr(32) $+ nested group) $+ : $+(%gstart,%b4,4here -Â»,%after,%gend) }
n206=          else {
n207=            %r = /(*UTF8)^\( ( (?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\(?:c.|[^Qc])|[^()]|\((?!\?\#)(?1)\))*+ ) \)/x
n208=            if ( $regsub(%after,%r,4 -Â»(\1)4 -Â»,%after) ) {
n209=              if ( %longdesc ) {
n210=                %cmd 5Syntax error in $iif(%ingroup,nested) group $+(%gstart,%b4,%after,%gend)
n211=                %r = $regex.ShowErrorInGroup(%target,$regml(1),%sep,%m,%notsep)
n212=              }
n213=              else { %cmd $regex.ShowErrorInGroup(%target,$regml(1),%sep,%m,%notsep) }
n214=            }
n215=            else {
n216=              %r = /(*UTF8)^\( ( (?:\(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\(?:c.|[^Qc])|[^()]|\((?!\?\#)(?1)\))*+ ) \)/x
n217=              if ( $regsub(%after,%r,4 -Â»(\1)4 -Â»,%after) ) {
n218=                if ( %longdesc ) {
n219=                  %cmd 5Syntax error in $iif(%ingroup,nested) group $+(%gstart,%b4,%after,%gend)
n220=                  %r = $regex.ShowErrorInGroup(%target,$regml(1),%sep,%m,%notsep)
n221=                }
n222=                else { %cmd $regex.ShowErrorInGroup(%target,$regml(1),%sep,%m,%notsep) }
n223=              }
n224=              else {
n225=                %r = /(*UTF8)([^\(]*+) \( ( \?\#[^ $+ $chr(41) $+ ]*+ |(?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\Q(?:(?!\\E).)*+\\E|\\c.|\\[^Qc]|[^()\\]|\((?2)\) )*+ ) \) /xg
n226=                %r = $regsub($mid(%after,2),%r,\1(\2),%after)
n227=                %cmd 5Unbalanced group starts in $+(%gstart,%b4,4here -Â»,6,$chr(40),,%after,%gend)
n228=              }
n229=            }
n230=          }
n231=        }
n232=      }
n233=      else { %cmd 4Unknown syntax error (I can't find the position) }
n234=    }
n235=  }
n236=  return
n237=  :error
n238=  regex.echo -a Your pattern caused an error in the script: $error
n239=  reseterror
n240=}
n241=alias -l regex.ShowErrorInGroup { returnex $regex.ShowErrorIn($1,$2,$3,$4,$5,$true) }
n242=alias -l regex.Explain {
n243=  var %target = $1, %pattern = $2, %lvl = $3
n244=  var %imode = $4, %smode = $5, %mmode = $6, %xmode = $7, %XXmode = $8, %Umode = $9
n245=  var %N, %i, %r, %null = (null, matches any position)
n246=  if ( %pattern == $null ) { $regex.RefOut(%target,%lvl) %null %quant }
n247=  elseif ( $regex(%pattern,m'(*UTF8)( \G ( (?: \(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\[bBAZzG] |[$^]| (?:(?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\\(?:c.|[^QcbBAZzGE]) |\((?:\?(?!\#))?+(?:\||(?2))*+\)| %notsep [^^$|*+?{()\[\\] ) (?:(?:[*+?]|\{\d++(?: $chr(44) \d*+)?\})[?+]?)?+ )*+ ) (?:\\Q(?:(?!\\E).)*+$)?+ ) (\|)'gx) ) {
n248=    %N = $v1
n249=    %i = $regml(0)
n250=    set -nl %patt.alt. $+ %lvl $+ . $+ $calc(%N + 1) $mid(%pattern,$calc($regml(%i).pos + $len($regml(%i))))
n251=    %i = 0
n252=    While (%i < %N) {
n253=      inc %i
n254=      set -nl %patt.alt. $+ %lvl $+ . $+ %i $regml($calc((%i - 1) * 3 + 1))
n255=    }
n256=    inc %N
n257=    %i = 0
n258=    While (%i < %N) {
n259=      inc %i
n260=      %r = $regex.Explain.Show(%target,%patt.alt. [ $+ [ %lvl ] $+ . $+ [ %i ] ] ,%lvl,$ord(%i) alternation: %patt.alt. [ $+ [ %lvl ] $+ . $+ [ %i ] ] ,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n261=    }
n262=  }
n263=  elseif ( $regex(%pattern,m'(*UTF8)\G(( (?:\Q[^]]\E|\[(?(?=\^)\^)\]?(?:\\(?:c.|[^c])|\[:[^\]\r\n]*:\]|[^\]\r\n])++\]) |\(\*(?:NO_START_OPT|CR|LF|CRLF|ANYCRLF|ANY|BSR_ANYCRLF|BSR_UNICODE|UTF8|UCP)\)|\\(?:[1-3][0-7]{2}|0?[1-7][0-7]|00?[1-7]|0)|\\(?:c.|k(?:<[^>]++>|'[^']++'|\{[^\}]++\})|g(?:\{(?:\-?[1-9]|[^\}]++)\}|[1-9])|[^Qcx^$|.*+?{()\[\]\\]) |\(\?\#[^ $+ $chr(41) $+ ]*+\) |\((?:\?[-+]?(?!\#))?+(?:\+|\||(?1))*+\)| [$^.] |(?:\\(?:[|.$^*+?{()\[\]\\]|x[\da-fA-F]{1,2})|[^^$|.*+?{()\[\\]|\[\\?[\\"^$|*+?{}()\[\]\/]\]) (?:(?:\\(?:[|.$^*+?{()\[\]\\]|x[\da-fA-F]{1,2}+)|[^^$|.*+?{()\[\\]|\[\\?[\\"^$|.*+?{}()\[\]\/]\])+(?![?*+{]))? |\\Q(?:(?!\\E).)*+(?:\\E|$) ) (?:([*+?]|\{\d++(?: $chr(44) \d*+)?+\})([?+]?+)|()()) )'gx) ) {
n264=    %N = $v1
n265=    %i = 0
n266=    var %j = 0, %refout, %quant
n267=    While (%i < %N) {
n268=      inc %i
n269=      inc %j 2
n270=      set -nl %patt.alt. $+ %lvl $+ . $+ %i $regml(%j)
n271=      inc %j
n272=      set -nl %patt.quant. $+ %lvl $+ . $+ %i $regml(%j)
n273=      inc %j
n274=      set -nl %patt.lazy. $+ %lvl $+ . $+ %i $regml(%j)
n275=    }
n276=    %i = 0
n277=    While (%i < %N) {
n278=      inc %i
n279=      var %token = %patt.alt. [ $+ [ %lvl ] $+ . $+ [ %i ] ]
n280=      %refout = $regex.RefOut(%target,%lvl)
n281=      %quant = $regex.Explain.Quantifiers(%patt.quant. [ $+ [ %lvl ] $+ . $+ [ %i ] ] ,%patt.lazy. [ $+ [ %lvl ] $+ . $+ [ %i ] ] ,%Umode)
n282=      if ( $regex(%token,/(*UTF8)^\(\?([-ismxXU]*+):(.*)\)$/) ) {
n283=        if ( $regml(1) == $null ) { %r = $regex.Explain.Show(%target,$regml(2),%lvl,Group %token %quant,%imode,%smode,%mmode,%xmode,%XXmode,%Umode) }
n284=        else {
n285=          var %groupmodes = $regml(1), %grouppattern = $regml(2)
n286=          %refout Group %token %quant
n287=          %r = $regex.ExplainModifiers(%target,%groupmodes,$calc(%lvl + 1))
n288=          var %gimode = %imode,%gsmode = %smode,%gmmode = %mmode,%gxmode = %xmode,%gXXmode = %XXmode,%gUmode = %Umode
n289=          if ( (%gimode) && ($regex(%groupmodes,/(*UTF8)-.*i/) == 1) ) { %gimode = $false }
n290=          elseif ( (!%gimode) && ($regex(%groupmodes,/(*UTF8)^[^-]*i/) == 1) ) { %gimode = $true }
n291=          if ( (%gsmode) && ($regex(%groupmodes,/(*UTF8)-.*s/) == 1) ) { %gsmode = $false }
n292=          elseif ( (!%gsmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*s/) == 1) ) { %gsmode = $true }
n293=          if ( (%gmmode) && ($regex(%groupmodes,/(*UTF8)-.*m/) == 1) ) { %gmmode = $false }
n294=          elseif ( (!%gmmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*m/) == 1) ) { %gmmode = $true }
n295=          if ( (%gxmode) && ($regex(%groupmodes,/(*UTF8)-.*x/) == 1) ) { %gxmode = $false }
n296=          elseif ( (!%gimode) && ($regex(%groupmodes,/(*UTF8)^[^-]*x/) == 1) ) { %gimode = $true }
n297=          if ( (%gXXmode) && ($regex(%groupmodes,/(*UTF8)-.*X/) == 1) ) { %gXXmode = $false }
n298=          elseif ( (!%gXXmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*X/) == 1) ) { %gXXmode = $true }
n299=          if ( (%gUmode) && ($regex(%groupmodes,/(*UTF8)-.*U/) == 1) ) { %gUmode = $false }
n300=          elseif ( (!%gUmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*U/) == 1) ) { %gUmode = $true }
n301=          %r = $regex.Explain.Recurse(%target,%grouppattern,%lvl,%gimode,%gsmode,%gmmode,%gxmode,%gXXmode,%gUmode)
n302=        }
n303=      }
n304=      elseif ( $regex(%token,/(*UTF8)^\(\?([-ismxXU]++)\)$/) ) {
n305=        var %groupmodes = $regml(1)
n306=        %refout %token Modifiers
n307=        %r = $regex.ExplainModifiers(%target,%groupmodes,$calc(%lvl + 1))
n308=        if ( (%imode) && ($regex(%groupmodes,/(*UTF8)-.*i/) == 1) ) { %imode = $false }
n309=        elseif ( (!%imode) && ($regex(%groupmodes,/(*UTF8)^[^-]*i/) == 1) ) { %imode = $true }
n310=        if ( (%smode) && ($regex(%groupmodes,/(*UTF8)-.*s/) == 1) ) { %smode = $false }
n311=        elseif ( (!%smode) && ($regex(%groupmodes,/(*UTF8)^[^-]*s/) == 1) ) { %smode = $true }
n312=        if ( (%mmode) && ($regex(%groupmodes,/(*UTF8)-.*m/) == 1) ) { %mmode = $false }
n313=        elseif ( (!%mmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*m/) == 1) ) { %mmode = $true }
n314=        if ( (%xmode) && ($regex(%groupmodes,/(*UTF8)-.*x/) == 1) ) { %xmode = $false }
n315=        elseif ( (!%imode) && ($regex(%groupmodes,/(*UTF8)^[^-]*x/) == 1) ) { %imode = $true }
n316=        if ( (%XXmode) && ($regex(%groupmodes,/(*UTF8)-.*X/) == 1) ) { %XXmode = $false }
n317=        elseif ( (!%XXmode) && ($regex(%groupmodes,/(*UTF8)^[^-]*X/) == 1) ) { %XXmode = $true }
n318=        if ( (%Umode) && ($regex(%groupmodes,/(*UTF8)-.*U/) == 1) ) { %Umode = $false }
n319=        elseif ( (!%Umode) && ($regex(%groupmodes,/(*UTF8)^[^-]*U/) == 1) ) { %Umode = $true }
n320=      }
n321=      elseif ( $regex(%token,/(*UTF8)^\(\*(?:NO_START_OPT|CR|LF|CRLF|ANYCRLF|ANY|BSR_ANYCRLF|BSR_UNICODE|UTF8|UCP)\)$/) ) {
n322=        %refout %token Undescribed specific verb
n323=      }
n324=      elseif ( $regex(%token,/(*UTF8)^\((?![?#])(.*)\)$/) ) {
n325=        inc -u0 %regex.BRs
n326=        %r = $regex.Explain.Show(%target,$regml(1),%lvl,$ord(%regex.BRs) Backreference %token %quant,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n327=      }
n328=      elseif ( $regex(%token,/(*UTF8)^\(\?=(.*)\)$/) ) {
n329=        %refout %token Positive LookAhead
n330=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n331=      }
n332=      elseif ( $regex(%token,/(*UTF8)^\(\?!(.*)\)$/) ) {
n333=        %refout %token Negative LookAhead
n334=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n335=      }
n336=      elseif ( $regex(%token,/(*UTF8)^\(\?<=(.*)\)$/) ) {
n337=        %refout %token Positive LookBehind
n338=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n339=      }
n340=      elseif ( $regex(%token,/(*UTF8)^\(\?<!(.*)\)$/) ) {
n341=        %refout %token Negative LookBehind
n342=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n343=      }
n344=      elseif ( $regex(%token,/(*UTF8)^\(\?>(.*)\)$/) ) {
n345=        %refout %token Atomic Group %quant
n346=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n347=      }
n348=      elseif ( $regex(%token,/(*UTF8)^\(\?\|(.*)\)$/) ) {
n349=        %refout %token Duplicate Subpattern Number Group %quant (every capturing group inside an alternation starts from the same numerical value)
n350=        %r = $regex.Explain.Recurse(%target,$regml(1),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n351=      }
n352=      elseif ( $regex(%token,/(*UTF8)^\(\?P?<([^>]++)>(.*)\)$/) ) {
n353=        %refout %token Named group ' $+ $regml(1) $+ '
n354=        %r = $regex.Explain.Recurse(%target,$regml(2),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n355=      }
n356=      elseif ( $regex(%token,/(*UTF8)^\(\?('[^']++')(.*)\)$/) ) {
n357=        %refout %token Named group $regml(1)
n358=        %r = $regex.Explain.Recurse(%target,$regml(2),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n359=      }
n360=      elseif ( $regex(%token,/(*UTF8)^\(\? (?#br1=cond)( \( ( (?: \[(?:\\c.|\\[^c]|\[:[^\]]*:\]|[^\]])++\] |\(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\c. |\\[^Qc] |\(\??(?2)\)| [^()\[] )*+ ) \) ) (?#br3=true)(( (?: \[(?:\\c.|\\[^c]|\[:[^\]]*:\]|[^\]])++\] |\(\?\#[^ $+ $chr(41) $+ ]*+\) |\\Q(?:(?!\\E).)*+\\E |\\c. |\\[^Qc] |\(\??(?:\||(?4))*+\)| [^|()\[] )*+ )) (?#br5=[|false]?) (?:\|(.*))?\) $ /x) ) {
n361=        var %pifcond = $regml(1), %piftrue = $regml(3), %piffalseexists = $iif($regml(0) >= 5,$true,$false), %piffalse = $regml(5), %newlvl = $calc(%lvl + 1), %newrefout = $regex.RefOut(%target,%newlvl)
n362=        %refout %token IF clause %quant
n363=        if ( $regex(%pifcond,/(*UTF8)^\(([+-])(\d++)\)$/) ) { %newrefout Condition: %pifcond True if the backreference $regml(2) is set $iif($regml(1) isin +-,2[relative] $getRecursion($regml(2),$regml(1))) }
n364=        elseif ( $regex(%pifcond,/(*UTF8)^\((<[^>]++>|'[^']++'|(?:R&)?\w+)\)$/) ) { 
n365=          if ($regml(1) === R) {
n366=            %newrefout Condition: %pifcond True if overall pattern recursion matches
n367=          }
n368=          elseif ($regex(abc,$regml(1),/(*UTF8)^R([1-9])$/)) {
n369=            %newrefout Condition: %pifcond True if $regml(abc,1) $+ $iif($regml(abc,1) == 1,st,$iif($regml(abc,1) == 2,nd,$iif($regml(abc,1) == 3,rd))) recursive subpattern matches
n370=          }
n371=          elseif ($regex(ab,$regml(1),/(*UTF8)^R&(.+)$/)) {
n372=            %newrefout Condition: %pifcond True if ' $+ $regml(ab,1) $+ ' recursive subpattern matches
n373=          }
n374=          elseif ($regex(def,$regml(1),/(*UTF8)^(<[^>]++>|'[^']++')$/)) {
n375=            %newrefout Condition: %pifcond True if the backreference ' $+ $right($left($regml(def,1),-1),-1) $+ ' is set
n376=          }
n377=          else {
n378=            %newrefout Condition: %pifcond True if the backreference ' $+ $regml(1) $+ ' is set
n379=          }
n380=        }
n381=        elseif ( $regex(%pifcond,/(*UTF8)^\(\?(<?)([=!])(.*)\)$/) ) {
n382=          %newrefout Condition: %pifcond Evaluates the $iif($regml(1) == !,negative,positive) look $+ $iif($regml(1) == $null,ahead,behind)
n383=          %r = $regex.Explain.Recurse(%target,$regml(3),%newlvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n384=        }
n385=        else { %newrefout Condition: %pifcond 4Error: It should be a zero width assertion }
n386=        %r = $regsub(%piftrue,/(*UTF8)^\(\?:(.*)\)$/,\1,%piftrue))
n387=        %r = $regex.Explain.Show(%target,%piftrue,%newlvl,True: %piftrue,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n388=        if ( %piffalseexists ) {
n389=          %r = $regsub(%piffalse,/(*UTF8)^\(\?:(.*)\)$/,\1,%piffalse))
n390=          %r = $regex.Explain.Show(%target,%piffalse,%newlvl,False: %piffalse,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n391=        }
n392=      }
n393=      elseif ( $regex(%token,/(*UTF8)^\(\?#([^ $+ $chr(41) $+ ]*+)\)$/) ) { %refout Comment: $regml(1) }
n394=      elseif ( $regex(%token,/(*UTF8)^\\(\d++)$/) && $regml(1) isnum 1 - %regex.BRs ) { %refout %token Matches text saved in BackRef $regml(1) %quant }
n395=      elseif ( $regex(%token,/(*UTF8)^\\g\{?(-?)([1-9])\}$/) ) { %refout %token Matches text saved in BackRef $regml(2) %quant $iif($regml(1) == -,2[relative] $getRecursion($regml(2),$regml(1))) }
n396=      elseif ( $regex(%token,/(*UTF8)^\\g\{?([^\}]+)\}$/) ) { %refout %token Matches text saved in BackRef ' $+ $regml(1) $+ ' %quant }
n397=      elseif ( $regex(%token,/(*UTF8)^\\k(?|<([^>]++)>|'([^']++)'|\{([^\}]++)\})$/) ) { %refout %token Matches text saved in BackRef ' $+ $regml(1) $+ ' %quant }
n398=      elseif ( $regex(%token,/(*UTF8)^\(\?P=(.+)\)$/) ) {
n399=        %refout %token Matches text saved in BackRef ' $+ $regml(1) $+ ' %quant
n400=      }
n401=      elseif ( $regex(%token,/(*UTF8)^\((\d++)\)$/) && $regml(1) isnum 1 - %regex.BRs ) { %refout %token Recurse BackRef $regml(1) %quant }
n402=      elseif ( %token == (?R) || %token == (?0) ) { %refout %token Recurse the whole pattern %quant }
n403=      elseif ( $regex(%token,/(*UTF8)^\Q(?\E([+-]?)([1-9]+)\)$/) ) { %refout %token Recurse the $regml(1) $+ $regml(2) $+ $iif($regml(2) == 1,st,$iif($regml(2) == 2,nd,$iif($regml(2) == 3,rd,th))) subpattern %quant $iif($regml(1) isin +-,2[relative] $getRecursion($regml(2),$regml(1))) }  
n404=      elseif ( $regex(%token,/(*UTF8)^\Q(?\E&([^&]+)\)$/) ) { %refout %token Recurse the subpattern after group ' $+ $regml(1) $+ ' %quant }  
n405=      elseif ( $regex(%token,/^(\[:(?:alnum|alpha|word|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit:):\])$/) && %lvl == 2) {
n406=        %refout $regml(1) $getCharClass($regml(1)) $replace($regml(1),:alnum:,A-Za-z0-9,:alpha:,A-Za-z,:blank:, \t,:cntrl:,\x00-\x1F\x7F,:graph:,\x21-\x7E,:lower:,a-z,:print:,\x20-\x7E,:punct:,$+($chr(93),$chr(91),!"#,$chr(36),%&',$chr(40),$chr(41),*+,$chr(44),./:;<=>?@\^_`,$chr(123),$chr(124),$chr(125),~-),:space:, \t\r\n\v\f,:upper:,A-Z,:xdigit:,A-Fa-f0-9) 14[POSIX]
n407=      }
n408=      elseif ( $regex(ncharclass,%token,/(*UTF8)^\[\^(.*)\]$/) ) {
n409=        var %z = $regsubex($regml(ncharclass,1),/(*UTF8)\\([^pPXxCbBDsSwWhHvVRcgGAzZKQEd0-9aefnrt-\\])/gi,\1)
n410=        var %newToken = $highlightClasses(%z)
n411=        %refout Negated char class %token %quant matches any char except: $replace(%newToken, $chr(1234), $chr(160))
n412=        noop $regex(posix,$regml(ncharclass,1),/(*UTF8)(\[:(?:alnum|alpha|word|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit:):\])/g)
n413=        var %a = 1
n414=        while (%a <= $regml(posix,0)) {
n415=          %r = $regex.Explain.Recurse(%target,$regml(posix,%a),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n416=          inc %a
n417=        }
n418=      }
n419=      elseif ( $regex(charclass,%token,/(*UTF8)^\[(.*)\]$/) ) { 
n420=        var %z = $regsubex($regml(charclass,1),/(*UTF8)\\([^pPXxCbBDsSwWhHvVRcgGAzZKQEd0-9aefnrt-\\])/gi,\1)
n421=        var %newToken = $highlightClasses(%z)
n422=        %refout Char class %token %quant matches one of the following chars: $replace(%newToken, $chr(1234), $chr(160))
n423=        noop $regex(posix,$regml(charclass,1),/(\[:(?:alnum|alpha|word|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit:):\])/g)
n424=        var %a = 1
n425=        while (%a <= $regml(posix,0)) {
n426=          %r = $regex.Explain.Recurse(%target,$regml(posix,%a),%lvl,%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n427=          inc %a
n428=        }
n429=      }
n430=      elseif ( $regex.Explain.Literal(%token,%imode,%smode,%mmode,%xmode,%XXmode,%Umode) != $null ) { %refout %token %quant $v1 }
n431=      elseif ( $regex(badbackref,%token,/(*UTF8)^\\(\d)$) ) { %refout %token %quant Possible error - Backreference to undefined numbered capturing group $regml(badbackref,1) }
n432=      else { 
n433=        %refout %token %quant 5(*) not described yet
n434=      }
n435=    }
n436=  }
n437=  else { $regex.RefOut(%target,%lvl) %token 4Unrecognized structure in %pattern 5No description for it yet (nothing's perfect) }
n438=}
n439=
n440=alias getCharClass {
n441=  if ($1 == [:alnum:]) { returnex Alphanumeric characters }
n442=  if ($1 == [:word:]) { returnex Alphanumeric characters plus "_" }
n443=  if ($1 == [:alpha:]) { returnex Alphabetic characters }
n444=  if ($1 == [:blank:]) { returnex Space and tab }
n445=  if ($1 == [:cntrl:]) { returnex Control characters }
n446=  if ($1 == [:digit:]) { returnex Digits }
n447=  if ($1 == [:graph:]) { returnex Visible characters }
n448=  if ($1 == [:lower:]) { returnex Lowercase letters }
n449=  if ($1 == [:print:]) { returnex Visible characters and the space character }
n450=  if ($1 == [:punct:]) { returnex Punctuation characters }
n451=  if ($1 == [:space:]) { returnex Whitespace characters }
n452=  if ($1 == [:upper:]) { returnex Uppercase letters }
n453=  if ($1 == [:xdigit:]) { returnex Hexadecimal digits }
n454=  if ($1 == [:space:]) { returnex Whitespace characters }
n455=}
n456=
n457=alias highlightClasses {
n458=  var %newToken = $1-, %msg
n459=  ;var %re2 = /(*UTF8)(?|((?<!\\)(?:\\\\))|(?<!\\)(?:\\\\)*((?:\\(?:[1-3][0-7]{2}|0?[1-7][0-7]|(?:00?)?[1-7]|0)|\\c[A-_]|\\x[\dA-F]{2}|(?!\\[dpPXxCbBDsSwWhHvVRcgGAzZKQE\-])(?:[^\\]|\\.))))-(?|((?<!\\)(?:\\\\))|(?<!\\)(?:\\\\)*((?:\\(?:[1-3][0-7]{2}|0?[1-7][0-7]|(?:00?)?[1-7]|0)|\\c[A-_]|\\x[\dA-F]{2}|(?!\\[dpPXxCbBDsSwWhHvVRcgGAzZKQE\-])(?:[^\\]|\\.))))/g
n460=  var %re2 = /(*UTF8)(?:\[:[^\]]*:\]|\\Q.*?\\E|(?|((?<!\\)(?:\\\\))|(?<!\\)(?:\\\\)*((?:\\(?:[1-3][0-7]{2}|0?[1-7][0-7]|(?:00?)?[1-7]|0)|\\c[A-_]|\\x[\dA-F]{2}|(?!\\[dpPXxCbBDsSwWhHvVRcgGAzZKQE\-])(?:[^\\]|\\.))))-((?<!\\)(?:\\\\)|\\(?:[1-3][0-7]{2}|0?[1-7][0-7]|(?:00?)?[1-7]|0)|\\c[A-_]|\\x[\dA-F]{2}|(?!\\[dpPXxCbBDsSwWhHvVRcgGAzZKQE\-])(?:[^\\]|\\.)))/g
n461=  if ($regex(er, %newToken, %re2) && - isin %newToken) {
n462=    var %i = 1, %a = $regml(er, 0)
n463=    %msg = 7[3valid7 character ranges in green, 4invalid7 in red7]
n464=    while (%i <= %a) {
n465=      var %t1 = $regml(er,%i), %t2 = $regml(er,$calc(%i + 1))
n466=      var %c1 = $asc(%t1), %c2 = $asc(%t2)
n467=      var %r = $+(%t1,-,%t2), %r1 = %t1, %r2 = %t2
n468=      if (%t1 == $chr(1234)) {
n469=        %c1 = 32
n470=        %r1 = $chr(160)
n471=      }
n472=      if (%t2 == $chr(1234)) {
n473=        %c2 = 32
n474=        %r2 = $chr(160)
n475=      }
n476=
n477=      if ($istokcs(\a \e \f \n \r \t \a \b,%t1,32)) {
n478=        %c1 = $replacecs(%t1,\a,7,\e,27,\f,12,\n,10,\r,13,\t,9,\a,7,\b,8)
n479=      }
n480=      elseif ($regex(f1,%t1,/(*UTF8)^\\([^c])$/)) {
n481=        %c1 = $asc($regml(f1,1))
n482=      }
n483=      if ($istokcs(\a \e \f \n \r \t \a \b,%t2,32)) {
n484=        %c2 = $replacecs(%t1,\a,7,\e,27,\f,12,\n,10,\r,13,\t,9,\a,7,\b,8)
n485=      }
n486=      elseif ($regex(f2,%t2,/(*UTF8)^\\([^c])$/)) {
n487=        %c2 = $asc($regml(f2,1))
n488=      }
n489=
n490=      if ($regex(o1, %t1, /(*UTF8)^\\([1-3][0-7]{2}|0?[1-7][0-7]|00?[1-7]|0)$/)) { 
n491=        %c1 = $base($regml(o1, 1),8,10,0) 
n492=        %r1 = $iif(%c1 == 50,$chr(160),$chr(%c1))
n493=      }
n494=      if ($regex(o2, %t2, /(*UTF8)^\\([1-3][0-7]{2}|0?[1-7][0-7]|00?[1-7]|0)$/)) { 
n495=        %c2 = $base($regml(o2, 1),8,10,0)
n496=        %r2 = $iif(%c2 == 50,$chr(160),$chr(%c2))
n497=      }
n498=
n499=      if ($regex(t1, %t1, /(*UTF8)^\\x([\dA-F]{2})$/)) { 
n500=        %c1 = $base($regml(t1, 1),16,10,0)
n501=        %r1 = $iif(%c1 == 50,$chr(160),$chr(%c1))
n502=      }
n503=      if ($regex(t2, %t2, /(*UTF8)^\\x([\dA-F]{2})$/)) {
n504=        %c2 = $base($regml(t2, 1),16,10,0)
n505=        %r2 = $iif(%c2 == 50,$chr(160),$chr(%c2))
n506=      }
n507=
n508=      if ($regex(t3, %t1, /(*UTF8)^\\c(.)$/)) { 
n509=        %c1 = $calc($asc($regml(t3,1)) - 64) 
n510=      }
n511=      if ($regex(t4, %t2, /(*UTF8)^\\c(.)$/)) { 
n512=        %c2 = $calc($asc($regml(t4,1)) - 64) 
n513=      }
n514=      if (%c1 > %c2) {
n515=        %newToken = $replacecs(%newToken,%r,$+(01,$chr(44),04,%r1,-,%r2,))
n516=      } 
n517=      else {
n518=        %newToken = $replacecs(%newToken,%r,$+(01,$chr(44),03,%r1,-,%r2,))
n519=      }
n520=      inc %i 2
n521=    }
n522=  }
n523=  returnex %newToken %msg
n524=}
n525=
n526=alias regex.Duplicate {
n527=  var %newstr, %i = 1, %str = $1-
n528=  while ($mid(%str,%i,1) != $null) { 
n529=    if ($v1 !isincs %newstr) {
n530=      %newstr = %newstr $+ $iif($v1 == $chr(32),$chr(160),$v1)
n531=    }
n532=    inc %i 
n533=  }
n534=  returnex %newstr
n535=}
n536=alias -l regex.Explain.Recurse { var %r = $regex.Explain($1,$2,$calc($3 + 1),$4,$5,$6,$7,$8,$9) }
n537=alias -l regex.RefOut Return { regex.Hash.AddTree $1 $2 }
n538=alias -l regex.Hash.AddTree {
n539=  var %regex.pat2 = $1, %text = $2-, %i = $hget(%regex.pat2,Tree.0)
n540=  if (%i == $null) { %i = 1 }
n541=  else { inc %i }
n542=  hadd -m %regex.pat2 Tree.0 %i
n543=  hadd %regex.pat2 Tree. $+ %i %text
n544=}
n545=alias -l regex.Hash2Tree {
n546=  var %regex.pat2 = $1, %i = $hget(%regex.pat2,Tree.0), %lvl, %txt, %y = 1
n547=  while (%y <= %i) {
n548=    tokenize 32 $hget(%regex.pat2,Tree. $+ %y)
n549=    if ( %lvl == $null ) { %lvl = $1 }
n550=    elseif ( $1 < %lvl ) { %lvl = $1 }
n551=    $iif($me ison %regex.pat2 || $query(%regex.pat2),regex.msg %regex.pat2,regex.echo -a) $regex.lvl($1,%lvl) $2-
n552=    inc %y
n553=  }
n554=}
n555=alias -l regex.lvl {
n556=  var %blank = $calc($2 - 1), %branch = $calc($1 - %blank - 1)
n557=  returnex $+(5,$chr(160),$str($str($chr(160),2),%blank),$str($+($chr(124),$chr(160)),%branch),+--Â»)
n558=}
n559=alias -l regex.Explain.Show {
n560=  var %target = $1, %pattern = $2, %lvl = $3, %expl = $4, %expl.lit, %r
n561=  var %imode = $5, %smode = $6, %mmode = $7, %xmode = $8, %XXmode = $9, %Umode = $10
n562=  %expl.lit = $regex.Explain.Literal(%pattern)
n563=  if (%expl.lit == $null) {
n564=    $regex.RefOut(%target,%lvl) %expl
n565=    %r = $regex.Explain(%target,%pattern,$calc(%lvl + 1),%imode,%smode,%mmode,%xmode,%XXmode,%Umode)
n566=  }
n567=  else { $regex.RefOut(%target,%lvl) %expl %expl.lit }
n568=}
n569=alias -l regex.Explain.Literal {
n570=  var %pattern = $1, %token = %pattern, %null = (null, matches any position), %r
n571=  var %imode = $2, %smode = $3, %mmode = $4, %xmode = $5, %XXmode = $6, %Umode = $7
n572=  %r = $regsub(patttriglit,%token,/(*UTF8)^\(\?\:(.*)\)$/,\1,%pattern)
n573=  if ( %token == $null ) { returnex %null }
n574=  elseif ( $v1 == ^ ) { returnex Start of $iif(%mmode,line,string) }
n575=  elseif ( $v1 == $ ) { returnex End of $iif(%mmode,line,string) }
n576=  elseif ( $v1 === \b ) { returnex Word boundary: match in between (^\w|\w$|\W\w|\w\W) }
n577=  elseif ( $v1 === \B ) { returnex Negated word boundary: match any position where \b doesn't match }
n578=  elseif ( $v1 === \A ) { returnex Start of string }
n579=  elseif ( $v1 === \Z ) { returnex End of string }
n580=  elseif ( $v1 === \z ) { returnex Absolute end of string }
n581=  elseif ( $v1 === \G ) { returnex End of previous match or start of string (useful with the global modifier) }
n582=  elseif ( $v1 === \K ) { returnex Resets the starting point of the reported match. Any previously matched characters are not included in the final matched sequence }
n583=  elseif ( $v1 == . ) { returnex Any character $iif(!%smode,(except newline)) %quant }
n584=  elseif ( $v1 === \d ) { returnex Digit [0-9] %quant }
n585=  elseif ( $v1 === \D ) { returnex Any character that's not a digit %quant }
n586=  elseif ( $v1 === \w ) { returnex Word character [a-zA-Z_\d] %quant }
n587=  elseif ( $v1 === \W ) { returnex Negated word character [^a-zA-Z_\d] %quant }
n588=  elseif ( $v1 === \s ) { returnex Whitespace [\t \r\n\f] %quant }
n589=  elseif ( $v1 === \S ) { returnex Any char except whitespaces [^\t \r\n\f] %quant }
n590=  elseif ( $v1 === \H ) { returnex Any horizontal whitespace character %quant }
n591=  elseif ( $v1 === \h ) { returnex Any character that's not a horizontal whitespace character %quant }
n592=  elseif ( $v1 === \V ) { returnex Any vertical whitespace character %quant }
n593=  elseif ( $v1 === \v ) { returnex Any character that's not a vertical whitespace character %quant }
n594=  elseif ( $regex(patttriglit,%token,/(*UTF8)^\\Q((?:(?!\\E).)*+)(?:\\E)?$/) ) { returnex Literal ` $+ $regml(patttriglit,1) $+ ` }
n595=  elseif ( $istokcs(\t [\t] \x09 $chr(9),%token,32) ) { returnex Tab (ASCII 9) }
n596=  elseif ( $istokcs(\r [\r] \xd \xD \x0d \x0D $cr,%token,32) ) { returnex Carriage returnex (ASCII 13) }
n597=  elseif ( $istokcs(\n [\n] \xa \xA \x0a \x0A $lf,%token,32) ) { returnex Line-feed (newline) (ASCII 10) }
n598=  elseif ( $istokcs(\f [\f] \xc \xC \x0c \x0C $chr(12),%token,32) ) { returnex Form feed (ASCII 12) }
n599=  elseif ( $istokcs(\a [\a] \x7 \x07 $chr(7),%token,32) ) { returnex Bell (ASCII 7) }
n600=  elseif ( $istokcs(\e [\e] \x1b \x1B $chr(27),%token,32) ) { returnex Esc (ASCII 27) }
n601=  elseif ( $istokcs(\x20. .[ ],%token,46) ) { returnex Space (ASCII 32) }
n602=  elseif ( $istokcs(\xa0 \xA0 $chr(160) \c?,%token,32) ) { returnex Hard Space (ASCII 160) }
n603=  elseif ( $istokcs(\x08 \x8 $chr(8) [\b],%token,32) ) { returnex BackSpace (ASCII 8) }
n604=  elseif ( $istokcs(\cb \x02 \x2 ,%token,32) ) { returnex Bold character (ASCII 2) }
n605=  elseif ( $istokcs(\c_ \x1F ,%token,32) ) { returnex Underline char (ASCII 31) }
n606=  elseif ( $istokcs(\cV \x16 ,%token,32) ) { returnex Reverse char (ASCII 22) }
n607=  elseif ( $istokcs(\cc \x03 \x3 ,%token,32) ) { returnex Color code (ASCII 3) }
n608=  elseif ( $istokcs(\co \x0F \xF \xf ,%token,32) ) { returnex Normal code (ASCII 15) }
n609=  elseif ( $regex(patttriglit,%token,/(*UTF8)^\\c(.)$/) ) { returnex %token %quant Matches Ctrl+ $+ $regml(patttriglit,1) }
n610=  elseif ( $regex(octal, %token,/(*UTF8)^\\([1-3][0-7]{2}|0?[1-7][0-7]|00?[1-7]|0)$/) ) {
n611=    returnex %quant Octal Literal ` $+ $chr($base($regml(octal, 1),8,10,0)) $+ `
n612=  }
n613=  elseif ( $regex(unsupported, %token, /(*UTF8)^\\[uUNLl]$/) ) {
n614=    returnex %quant 4Unsupported escape squence. Will generate error in PCRE.
n615=  }
n616=  ;elseif ( $regex(patttriglit,%token,/(*UTF8)^(?:\\(?:x[0-9a-zA-Z]{1,2}|[\\"^$|.*+?{}()\[\]\/])|[^^$|.*+?{}()\[\]\\]|\[\\?[\\"^$|.*+?{}()\[\]\/]\])++$/) ) {
n617=  elseif ( $regex(patttriglit,%token,/(*UTF8)^(?:\\(?:[^pPXxCbBdDsSwWhHvVRnrcgGAzZKQEtf1-9uUlLN]|x[0-9a-zA-Z]{1,2}|[-'#&%Â½Â§Â´`Â¨~;,:_Â¤Â£@<>\\"^$|.*+?{!}()\[\]\/])|[^^$|.*+?{}()\[\\]|\[\\?[\\"^$|.*+?{}()\[\]\/]\])++$/) ) {
n618=    if ( $regex(patttriglit,%token,/(*UTF8)(\\([^x])|\[\\?([\\"^$|.*+?{}()\[\]\/])\]|\\x([0-9a-zA-Z]{1,2}))/g) ) {
n619=      %r = $calc($regml(patttriglit,0) - 1)
n620=      var %newchar
n621=      While (%r > 0) {
n622=        if ( $left($regml(patttriglit,%r),2) === \x ) { %newchar = $chr($base($regml(patttriglit,$calc(%r + 1)),16,10)) }
n623=        else { %newchar = $regml(patttriglit,$calc(%r + 1)) }
n624=        %token = $+($left(%token,$calc($regml(patttriglit,%r).pos - 1)),%newchar,$mid(%token,$calc($regml(patttriglit,%r).pos + $len($regml(patttriglit,%r)))))
n625=        dec %r 2
n626=      }
n627=    }
n628=    returnex Literal ` $+ %token $+ `
n629=  }
n630=}
n631=
n632=alias -l regex.Explain.Quantifiers {
n633=  if (!$1) { return }
n634=  var %quant = $1, %possesive = $2, %Umode = $3, %lazy, $false, %from, %to, %inf = infinite, %extra, %extraK = 2
n635=  %lazy = %Umode
n636=  if ( %quant == * ) {
n637=    %from = %inf
n638=    %to = 0
n639=  }
n640=  elseif ( %quant == + ) {
n641=    %from = %inf
n642=    %to = 1
n643=  }
n644=  elseif ( %quant == ? ) {
n645=    %from = 1
n646=    %to = 0
n647=  }
n648=  elseif ( $regex(explainquantif,%quant,/(*UTF8)^\{(\d++)(?:(,)(\d*+))?\}$/) ) {
n649=    %to = $regml(explainquantif,1)
n650=    ;%from = $iif($regml(explainquantif,3) == $null && $regml(explainquantif,2) != $null,%inf,$iif($regml(explainquantif,3) == $null,%inf,$v1))
n651=    if ($regml(explainquantif,2) != $null && $regml(explainquantif,3) == $null) {
n652=      %from = %inf
n653=    }
n654=    elseif ($regml(explainquantif,2) != $null && $regml(explainquantif,3) != $null) {
n655=      %from = $regml(explainquantif,3)
n656=    }
n657=    else {
n658=      %from = %to
n659=    }
n660=  }
n661=  if ( %possesive == + ) { %extra = %extraK $+ [possessive] }
n662=  elseif ( %possesive == ? ) {
n663=    if ( %lazy ) {
n664=      %lazy = $false
n665=      %extra = %extraK $+ [greedy]
n666=    }
n667=    else {
n668=      %lazy = $true
n669=      %extra = %extraK $+ [lazy]
n670=    }
n671=  }
n672=  if ( %lazy ) {
n673=    %lazy = %to
n674=    %to = %from
n675=    %from = %lazy
n676=  }
n677=  returnex 14 $+ %from $iif(%to != %from,to %to) times %extra
n678=  ;returnex 14 $+ %to $iif(%to != %from,to %from) times %extra
n679=}
n680=alias -l regex.ExplainModifiers {
n681=  var %target = $1, %modif = $2, %letter, %lvl = $3, %i = 0, %N = $len(%modif), %desc, %on = $true
n682=  While ( %i < %N ) {
n683=    inc %i
n684=    %letter = $mid(%modif,%i,1)
n685=    if ( %letter == - ) {
n686=      %on = $false
n687=      Continue
n688=    }
n689=    elseif ( %letter === g ) { %desc = global. All matches (don't return on first match) }
n690=    elseif ( %letter === i ) {
n691=      if ( %on ) { %desc = insensitive. Case insensitive match (ignores case of [a-zA-Z]) }
n692=      else { %desc = 7-insensitive. Case sensitive match }
n693=    }
n694=    elseif ( %letter === s ) {
n695=      if ( %on ) { %desc = single line. Dot (or negated charclass) matches newline characters }
n696=      else { %desc = 7-single line. A dot (or negated charclass) won't match \n }
n697=    }
n698=    elseif ( %letter === S ) { %desc = Strip. Ignores control codes in text (mIRC only) }
n699=    elseif ( %letter === m ) {
n700=      if ( %on ) { %desc = multi-line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string) }
n701=      else { %desc = 7-multi-line. ^ and $ match not only begin/end of string }
n702=    }
n703=    elseif ( %letter === o ) { %desc = option. This modifier was introduced as a mnemonic rule }
n704=    elseif ( %letter === x ) {
n705=      if ( %on ) { %desc = extended. Spaces and text after a `#` in the pattern are ignored }
n706=      else { %desc = 7-extended. Spaces in pattern are literal spaces }
n707=    }
n708=    elseif ( %letter === X ) {
n709=      if ( %on ) { %desc = eXtra. a \ followed by a letter with no special meaning is faulted }
n710=      else { %desc = 7-eXtra. a \ followed by a letter with no special meaning matches that letter literally }
n711=    }
n712=    elseif ( %letter === A ) { %desc = Anchored. Pattern is forced to ^ }
n713=    elseif ( %letter === U ) {
n714=      if ( %on ) { %desc = Ungreedy. The match becomes lazy by default. Now a ? following a quantifier makes it greedy. }
n715=      else { %desc = 7-Ungreedy. The match becomes greedy by default. }
n716=    }
n717=    else { %desc = no description for it yet. }
n718=    $regex.RefOut(%target,%lvl) %letter $iif(%on,modifier,off) $+ : %desc
n719=  }
n720=}
n721=alias re {
n722=  var %input = $1-, %sre = /(*UTF8)^(?:(.*)\s)s([^\w\s\\])((?:\\.|(?!\\|\2).)*)\2((?:\\.|(?!\\|\2).)*)\2([gisSmoxXAU]*)\s*$/, $&
n723=    %mre1 = /(*UTF8)^(.*)\sm?([^\w\s\\])((?:\\.|(?!\\|\2).)*)\2([gisSmoxXAU]*)\s*$/, %ret = $iif($isid,returnex,echo -ti12a)
n724=  if ($regex(sre,%input,%sre) isnum 1-) {
n725=    var %text = $regml(sre,1), %delim = $regml(sre,2), %pat = $regml(sre,3), %repl = $regml(sre,4), %flags = $regml(sre,5)
n726=    if (%delim != /) {
n727=      if (%delim isin |^()[{.+*?\$#) var %escape = \ $+ %delim
n728=      else var %escape = %delim
n729=      var %pat = $regsubex(%pat,/(*UTF8)(*UTF8)(?<!\\)((?:\\\\)*)\\( $+ %escape $+ )/g,\1\2), %pat = $regsubex(%pat,/(*UTF8)(?<!\\)((?:\\\\)*)\//g,\1\/)
n730=    }
n731=    var %repl = $regsubex(%repl,/(*UTF8)(?<!\\)((?:\\\\)*)\\( $+ %delim $+ )/g,\1\2), %result
n732=    if ($regsub(repat,%text,$+(/(*UTF8),%pat,/,%flags),%repl,%result) isnum 1-) {
n733=      %ret $+([Result:,$chr(32),$v1,]) %result
n734=    }
n735=    else {
n736=      %ret Result: %result
n737=    }
n738=  }
n739=  elseif (($regex(mre,%input,%mre1) isnum 1-)) {
n740=    var %text = $regml(mre,1), %delim = $regml(mre,2), %pat = $regml(mre,3), %flags = $regml(mre,4)
n741=    if (%delim != /) {
n742=      if (%delim isin |^()[{.+*?\$#) var %escape = \ $+ %delim
n743=      else var %escape = %delim
n744=      var %pat = $regsubex(%pat,/(*UTF8)(?<!\\)((?:\\\\)*)\\( $+ %escape $+ )/g,\1\2), %pat = $regsubex(%pat,/(*UTF8)(?<!\\)((?:\\\\)*)\//g,\1\/)
n745=    }
n746=    var %result
n747=    if ($regex(repat,%text,$+(/(*UTF8),%pat,/,%flags)) isnum 1-) {
n748=      %result = [Result: $v1 $+ ] $chr(9999)
n749=      var %n = $regml(repat,0), %i = 1
n750=      var %m = $re_consumed(re,%text,$+(/(*UTF8),%pat,/,%flags),1), %pos = $re_consumed(re,1).pos
n751=      var %fullmatch = $+([0:,%pos,-,$iif(%m == $null,?,$calc(%pos + $len(%m) -1)),:,$chr(32),%m,])
n752=
n753=      while (%i <= %n) {
n754=        ;%result = %result $+ $iif(%i != 1,$chr(44)) $regml(repat,%i)
n755=        var %result $addtok(%result,$+([,%i,:,$regml(repat,%i).pos,-,$iif($regml(repat,%i) == $null,?,$calc(($regml(repat,%i).pos) + $len($regml(repat,%i)) -1)),:,$chr(32),$regml(repat,%i),]),32)
n756=        inc %i
n757=      }
n758=      %ret $replace(%result,$chr(9999),%fullmatch)
n759=    }
n760=    else {
n761=      %ret [Result: 0]
n762=    }
n763=  }
n764=  else {
n765=    %ret Syntax is: !regex <text> /regex/, !regex <text> s/regex/replacement/
n766=  }
n767=}
n768=alias msg {
n769=  !msg $1 $replace($2-,$chr(4000),$chr(123),$chr(1000),$chr(125),$chr(1234),$chr(32))
n770=}
n771=
n772=alias getRecursion {
n773=  returnex (refers to the $1 $+ $iif($1 == 1,st,$iif($1 == 2,nd,$iif($1 == 3,rd))) most recently opened parentheses $iif($2 == -,preceding,subsequent to) the recursion)
n774=}
n775=
n776=/*
n777={
n778=
n779=  $re_parse(<expression>)[.prop]
n780=
n781=  Takes in an mIRC regular expression and returns information
n782=  about it. Note the distinction between an mIRC regex and a
n783=  PCRE one: mIRC, being the application, interprets pattern
n784=  enclosing characters and modifiers. Thus the expressions that
n785=  this alias deals with are ones that are used, for example, in
n786=  $regex(), $regsub(), /filter -g, $hfind(), etc.
n787=
n788=  Properties:
n789=
n790=  .compiles  - Returns $true if the pattern can be successfully
n791=  compiled by PCRE, $false otherwise.
n792=  .delimiter - Returns the pattern delimiter if one is used.
n793=  .pattern   - Returns the expression fed to the PCRE library.
n794=  .modifiers - Returns the modifiers in the expression, if any.
n795=  .all       - Returns the name of a hash table containing results.
n796=
n797=  .all saves you having to re-call $re_parse() if you need a full
n798=  set of data. The hash table is filled with item names that match
n799=  the properties above, and the scripter should ensure to /hfree
n800=  the table when they are finished using it.
n801=
n802=  Without a property, it defaults to .compiles.
n803=
n804=}
n805=*/
n806=
n807=alias re_parse {
n808=
n809=  var %re = /(*UTF8) ^ (?| m(.?)|(/?) ) ( (?: \(\* (?:                      $&
n810=    NO_START_OPT|CR|LF|CRLF|ANYCRLF|ANY|BSR_ANYCRLF|BSR_UNICODE|UTF8|UCP    $&
n811=    ) \) )* ) (?| (.*)\1|(.*) ) (.*) /xs
n812=
n813=  if (!$isutf($utfencode($1))) %re = 
n814=
n815=  noop $regex(re_parse, $1, %re)
n816=
n817=  if ($prop $+ * iswm delimiter) returnex $regml(re_parse, 1)
n818=  if ($v1 iswm verbs) returnex $regml(re_parse, 2)
n819=  if ($v1 iswm pattern) returnex $regml(re_parse, 3)
n820=
n821=  var %modifiers = $regsubex(re_parse2, $regml(re_parse, 4), /[^AEgimsSUxX].*/s, )
n822=
n823=  if ($v1 iswm modifiers) returnex %modifiers
n824=
n825=  var %compiles = $istok($regex(,                                                  $&
n826=    $+(/, $regml(re_parse, 2), |, $regml(re_parse, 3), /, $remove(%modifiers, g))  $&
n827=    ), 1, 1)
n828=
n829=  if ($v1 iswm all) {
n830=    var %name
n831=
n832=    :do {
n833=      %name = re_parse $+ $rand(1, $not(0))
n834=    }
n835=    while ($hget(%name)) goto do
n836=
n837=    ; "do/while in mIRC??" ;)
n838=
n839=    hmake %name 10
n840=    hadd %name compiles %compiles
n841=    hadd %name delimiter $regml(re_parse, 1)
n842=    hadd %name verbs $regml(re_parse, 2)
n843=    hadd %name pattern $regml(re_parse, 3)
n844=    hadd %name modifiers %modifiers
n845=
n846=    returnex %name
n847=  }
n848=
n849=  if (!%re) returnex $false
n850=
n851=  returnex %compiles
n852=}
n853=
n854=/*
n855={
n856=
n857=  $re_consumed([name,] text, re [, N])[.pos]
n858=  $re_consumed([name,] N)[.pos]
n859=
n860=  Returns information about the parts of 'text' that are
n861=  matched by 're'. 
n862=
n863=  Syntax is sort of a combination of $regex() and $regml().
n864=
n865=  If 'name' is supplied then you can refer to it later with
n866=  $re_consumed(name, N)[.pos].
n867=
n868=  If 'name' isn't supplied then you can refer to it later
n869=  with $re_consumed(N)[.pos]
n870=
n871=  N is optional, to return the Nth consumed substring, not
n872=  relevant unless you use the 'g' modifier.
n873=
n874=  If N is not supplied then it defaults to 0 if the 'g'
n875=  modifier is used in the expression, '1' otherwise.
n876=
n877=}
n878=*/
n879=
n880=alias re_consumed {
n881=  var %marker1 = $cr, %marker2 = $lf, %prop = $iif($prop == pos, .pos)
n882=
n883=  if ($1- isnum) {
n884=    returnex $regml(re_consumed_, $1) [ $+ [ %prop ] ]
n885=  }
n886=
n887=  if ($2- isnum) {
n888=    returnex $regml(re_consumed_ $+ $1, $2) [ $+ [ %prop ] ]
n889=  }
n890=
n891=  if ($0 isnum 2-4) {
n892=
n893=    if ($0 == 2) || ($3- isnum) {
n894=      var %name re_consumed_, %str = $1 ., %re = $2 ., %N $3
n895=    }
n896=    else {
n897=      var %name = re_consumed_ $+ $1, %str = $2 ., %re = $3 ., %N $4
n898=    }
n899=
n900=    var %hsh = $re_parse($left(%re, -2)).all
n901=
n902=    if (g isin $hget(%hsh, modifiers)) && (%N == $null) {
n903=      %N = 0
n904=    }
n905=
n906=    if ($hget(%hsh, compiles)) {
n907=      var %num = $regex(%name,                                                        $&
n908=        $regsubex(str, $left(%str, -2), / $+ $hget(%hsh, verbs) $+                    $&
n909=        $hget(%hsh, pattern) $+ \E\K/ $+ $hget(%hsh, modifiers), %marker1),           $&
n910=        $+(/^\Q, $replacecs($regsubex(re, $left(%str, -2), $left(%re, -2), %marker2), $&
n911=        \E, \E\\E\Q, %marker2, \E(.*)\Q $+ %marker1), \E$/UsA))
n912=
n913=      hfree %hsh
n914=      returnex $regml(%name, $int(%N 1)) [ $+ [ %prop ] ]
n915=    }
n916=
n917=    hfree %hsh
n918=  }
n919=}
